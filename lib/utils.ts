import { type ClassValue, clsx } from 'clsx'
import { twMerge } from 'tailwind-merge'
import queryString from 'query-string'
import { BADGE_CRITERIA } from '@/constants'
import { BadgeCounts } from '@/types'

// generated by shadcn
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

// generated by chatgpt
export const getTimestamp = (createdAt: Date): string => {
  const now = new Date()
  const diffInSeconds = Math.floor((now.getTime() - createdAt.getTime()) / 1000)

  // Define time intervals in seconds
  const intervals = {
    year: 31536000,
    month: 2592000,
    week: 604800,
    day: 86400,
    hour: 3600,
    minute: 60
  }

  // Calculate time differences
  let intervalCount: number
  let intervalUnit: string

  if (diffInSeconds >= intervals.year) {
    intervalCount = Math.floor(diffInSeconds / intervals.year)
    intervalUnit = intervalCount === 1 ? 'year' : 'years'
  } else if (diffInSeconds >= intervals.month) {
    intervalCount = Math.floor(diffInSeconds / intervals.month)
    intervalUnit = intervalCount === 1 ? 'month' : 'months'
  } else if (diffInSeconds >= intervals.week) {
    intervalCount = Math.floor(diffInSeconds / intervals.week)
    intervalUnit = intervalCount === 1 ? 'week' : 'weeks'
  } else if (diffInSeconds >= intervals.day) {
    intervalCount = Math.floor(diffInSeconds / intervals.day)
    intervalUnit = intervalCount === 1 ? 'day' : 'days'
  } else if (diffInSeconds >= intervals.hour) {
    intervalCount = Math.floor(diffInSeconds / intervals.hour)
    intervalUnit = intervalCount === 1 ? 'hour' : 'hours'
  } else if (diffInSeconds >= intervals.minute) {
    intervalCount = Math.floor(diffInSeconds / intervals.minute)
    intervalUnit = intervalCount === 1 ? 'minute' : 'minutes'
  } else {
    intervalCount = diffInSeconds
    intervalUnit = intervalCount === 1 ? 'second' : 'seconds'
  }

  return `${intervalCount} ${intervalUnit} ago`
}

// generated by chatgpt
export const formatNumber = (num: number): string => {
  if (num >= 1000000) {
    return (num / 1000000).toFixed(1) + 'M'
  } else if (num >= 1000) {
    return (num / 1000).toFixed(1) + 'K'
  } else {
    return num.toString()
  }
}

// generated by chatgpt
export function formatDate(date: Date): string {
  const options: Intl.DateTimeFormatOptions = { year: 'numeric', month: 'long' }
  return new Intl.DateTimeFormat('en-US', options).format(date)
}

type UrlQueryParams = {
  params: string
  key: string
  value: string | null
}

export function formUrlQuery({ params, key, value }: UrlQueryParams) {
  const query = queryString.parse(params)

  query[key] = value

  return queryString.stringifyUrl(
    {
      url: window.location.pathname,
      query
    },
    { skipNull: true }
  )
}

type BadgeParams = {
  criteria: {
    type: keyof typeof BADGE_CRITERIA
    count: number
  }[]
}

export const assignBadges = ({ criteria }: BadgeParams) => {
  const badgeCounts: BadgeCounts = {
    GOLD: 0,
    SILVER: 0,
    BRONZE: 0
  }

  criteria.forEach((item) => {
    const { type, count } = item
    const badgeLevels: any = BADGE_CRITERIA[type]

    Object.keys(badgeLevels).forEach((level: any) => {
      if (count >= badgeLevels[level]) badgeCounts[level as keyof BadgeCounts] += 1
    })
  })

  return badgeCounts
}
